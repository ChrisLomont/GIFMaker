#pragma once
/*
MIT License

Copyright (c) 2024 Chris Lomont

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// single file, simple animated GIF file generator
// modern C++
// Chris Lomont 2022

#include <string>
#include <cstdint>
#include <unordered_map>
#include <fstream>
#include <array>
// GIF writer writes GIFs from RGBA byte buffer frames
//
class GIFWriter
{
	/* TODO
	 - get transparent working cleanly
	 - put in palettized index to gif ability
	 - X - perhaps minor compression tbl
	 - X - faster if easy and small	 
	 */

	// good GIF format description
	// https://giflib.sourceforge.net/whatsinagif/index.html
	// also the gif89a.txt standard, found online

	std::ofstream os;
	int w{ 0 }, h{0};
	int bitDepth = 8; // 8 bits palette - smaller? todo
public:
	// set these before any writing
	bool useLocalPalettes  = false;
	bool useGlobalPalette = true;
	bool hasTransparency = false;
	int transparentIndex = 0;
	// set to true for better compression, more memory use during compression
	bool goodCompression = true;

	// palettes https://fornaxvoid.com/colorpalettes/
	// Deluxe Paint 256 color palette
	// todo - can clamp to mults of 16, pack it more
	std::vector<uint8_t> palette{
		0x00, 0x00, 0x00, 0x30, 0x8a, 0x45, 0xe3, 0xe3, 0xe3, 0x71, 0x71, 0x71, 0xf3, 0x00, 0x00, 0x92, 0x00, 0x00, 0xf3, 0xd3, 0xd3, 0xf3, 0xa2, 0x51, 0xf3, 0xf3, 0xd3, 0xe3, 0xd3, 0x00, 0xd3, 0xf3, 0x51, 0xd3, 0xf3, 0xd3, 0x00, 0xf3, 0x00, 0x00, 0x92, 0x00, 0xd3, 0xf3, 0xf3, 0x00, 0xe3, 0xe3, 0xaa, 0xaa, 0xaa, 0x45, 0xdf, 0x45, 0xdf, 0xdf, 0xdf, 0x71, 0x71, 0x71, 0xe3, 0x00, 0x00, 0x82, 
		0x00, 0x00, 0xf3, 0xb2, 0xb2, 0xf3, 0x92, 0x41, 0xf3, 0xf3, 0xb2, 0xc3, 0xc3, 0x00, 0xc3, 0xf3, 0x41, 0xb2, 0xf3, 0xb2, 0x00, 0xe3, 0x00, 0x00, 0x82, 0x00, 0xb2, 0xf3, 0xf3, 0x00, 0xc3, 0xc3, 0x65, 0x65, 0x65, 0x45, 0xdf, 0xcf, 0xdf, 0xdf, 0xdf, 0x65, 0x65, 0x65, 0xe3, 0x00, 0x00, 0x71, 0x00, 0x00, 0xf3, 0x92, 0x92, 0xf3, 0x82, 0x20, 0xf3, 0xf3, 0x92, 0xb2, 0xa2, 0x00, 0xb2, 0xf3, 
		0x20, 0x92, 0xf3, 0x92, 0x00, 0xe3, 0x00, 0x00, 0x71, 0x00, 0x92, 0xf3, 0xf3, 0x00, 0xb2, 0xb2, 0xdf, 0xdf, 0xdf, 0x30, 0x8a, 0xcf, 0xc3, 0xc3, 0xc3, 0x51, 0x51, 0x51, 0xd3, 0x00, 0x00, 0x71, 0x00, 0x00, 0xf3, 0x71, 0x71, 0xf3, 0x71, 0x00, 0xf3, 0xf3, 0x71, 0x92, 0x92, 0x00, 0xa2, 0xf3, 0x00, 0x82, 0xf3, 0x71, 0x00, 0xd3, 0x00, 0x00, 0x71, 0x00, 0x71, 0xf3, 0xf3, 0x00, 0x92, 0x92, 
		0xcf, 0x30, 0x45, 0x8a, 0x8a, 0xdf, 0xb2, 0xb2, 0xb2, 0x41, 0x41, 0x41, 0xc3, 0x00, 0x00, 0x61, 0x00, 0x00, 0xf3, 0x51, 0x51, 0xe3, 0x61, 0x00, 0xf3, 0xf3, 0x51, 0x82, 0x82, 0x00, 0x92, 0xe3, 0x00, 0x61, 0xf3, 0x51, 0x00, 0xc3, 0x00, 0x00, 0x61, 0x00, 0x51, 0xf3, 0xf3, 0x00, 0x82, 0x82, 0xdf, 0x8a, 0x45, 0x45, 0x30, 0xcf, 0xaa, 0xaa, 0xaa, 0x30, 0x30, 0x30, 0xb2, 0x00, 0x00, 0x51, 
		0x00, 0x00, 0xf3, 0x41, 0x41, 0xc3, 0x61, 0x00, 0xf3, 0xf3, 0x41, 0x71, 0x61, 0x00, 0x82, 0xc3, 0x00, 0x41, 0xf3, 0x41, 0x00, 0xb2, 0x00, 0x00, 0x51, 0x00, 0x41, 0xf3, 0xf3, 0x00, 0x71, 0x71, 0xcf, 0xdf, 0x45, 0xcf, 0x30, 0xcf, 0x92, 0x92, 0x92, 0x20, 0x20, 0x20, 0xb2, 0x00, 0x00, 0x41, 0x00, 0x00, 0xf3, 0x20, 0x20, 0xb2, 0x51, 0x00, 0xf3, 0xf3, 0x20, 0x51, 0x51, 0x00, 0x71, 0xb2, 
		0x00, 0x20, 0xf3, 0x20, 0x00, 0xb2, 0x00, 0x00, 0x41, 0x00, 0x20, 0xf3, 0xf3, 0x00, 0x51, 0x51, 0x8a, 0x8a, 0x30, 0xdf, 0x8a, 0xcf, 0x82, 0x82, 0x82, 0x20, 0x20, 0x20, 0xa2, 0x00, 0x00, 0x41, 0x00, 0x00, 0xf3, 0x00, 0x00, 0x92, 0x41, 0x00, 0xf3, 0xf3, 0x00, 0x41, 0x41, 0x00, 0x61, 0x92, 0x00, 0x00, 0xf3, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x41, 0x00, 0x00, 0xf3, 0xf3, 0x00, 0x41, 0x41, 
		0x51, 0xb2, 0xf3, 0xd3, 0xd3, 0xf3, 0x00, 0x00, 0xf3, 0x00, 0x00, 0x92, 0xf3, 0xd3, 0xf3, 0x92, 0x00, 0xe3, 0xf3, 0xd3, 0xf3, 0xe3, 0x00, 0xe3, 0xf3, 0xe3, 0xd3, 0xc3, 0x92, 0x82, 0x82, 0x41, 0x30, 0x51, 0x10, 0x10, 0xf3, 0x51, 0x51, 0xc3, 0x20, 0x20, 0x20, 0xc3, 0x30, 0x51, 0x20, 0xc3, 0x41, 0xb2, 0xf3, 0xb2, 0xb2, 0xf3, 0x00, 0x00, 0xe3, 0x00, 0x00, 0x82, 0xe3, 0xb2, 0xf3, 0x82, 
		0x00, 0xc3, 0xf3, 0xb2, 0xf3, 0xc3, 0x00, 0xc3, 0xf3, 0xd3, 0xd3, 0xb2, 0x82, 0x71, 0x82, 0x30, 0x30, 0x41, 0x10, 0x00, 0xf3, 0xb2, 0x82, 0xc3, 0x41, 0x20, 0x20, 0xc3, 0x51, 0x82, 0x20, 0xc3, 0x20, 0xa2, 0xf3, 0x92, 0x92, 0xf3, 0x00, 0x00, 0xe3, 0x00, 0x00, 0x71, 0xd3, 0x92, 0xf3, 0x71, 0x00, 0xb2, 0xf3, 0x92, 0xf3, 0xb2, 0x00, 0xb2, 0xf3, 0xd3, 0xc3, 0xb2, 0x71, 0x61, 0x71, 0x30, 
		0x20, 0x41, 0x00, 0x00, 0xf3, 0xf3, 0x82, 0xc3, 0x71, 0x20, 0x20, 0xc3, 0x82, 0xb2, 0x20, 0xc3, 0x00, 0x92, 0xf3, 0x71, 0x82, 0xf3, 0x00, 0x00, 0xd3, 0x00, 0x00, 0x71, 0xd3, 0x71, 0xf3, 0x61, 0x00, 0x92, 0xf3, 0x71, 0xf3, 0x92, 0x00, 0x92, 0xe3, 0xc3, 0xb2, 0xa2, 0x71, 0x61, 0x71, 0x30, 0x20, 0x30, 0x00, 0x00, 0x82, 0xf3, 0x82, 0xc3, 0x92, 0x20, 0x20, 0xc3, 0xb2, 0xc3, 0x20, 0xa2, 
		0x00, 0x82, 0xe3, 0x51, 0x61, 0xf3, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x61, 0xc3, 0x51, 0xf3, 0x51, 0x00, 0x82, 0xf3, 0x51, 0xf3, 0x82, 0x00, 0x82, 0xe3, 0xb2, 0xa2, 0xa2, 0x61, 0x51, 0x71, 0x20, 0x20, 0x30, 0x00, 0x00, 0x82, 0xf3, 0xf3, 0xc3, 0xc3, 0x20, 0x20, 0xa2, 0xc3, 0xc3, 0x20, 0x82, 0x00, 0x71, 0xc3, 0x41, 0x41, 0xf3, 0x00, 0x00, 0xb2, 0x00, 0x00, 0x51, 0xb2, 0x41, 0xf3, 0x41, 
		0x00, 0x71, 0xf3, 0x41, 0xf3, 0x61, 0x00, 0x71, 0xd3, 0xb2, 0x92, 0xa2, 0x61, 0x51, 0x61, 0x20, 0x10, 0x20, 0x00, 0x00, 0x82, 0x82, 0xf3, 0x92, 0xc3, 0x20, 0x20, 0x71, 0xc3, 0xc3, 0x20, 0x51, 0x00, 0x61, 0xb2, 0x20, 0x20, 0xf3, 0x00, 0x00, 0xb2, 0x00, 0x00, 0x41, 0xb2, 0x20, 0xf3, 0x30, 0x00, 0x51, 0xf3, 0x20, 0xf3, 0x51, 0x00, 0x51, 0xd3, 0xa2, 0x92, 0x92, 0x51, 0x41, 0x61, 0x10, 
		0x10, 0x20, 0x00, 0x00, 0xb2, 0x82, 0xf3, 0x71, 0xc3, 0x20, 0x20, 0x51, 0xc3, 0xc3, 0x20, 0x20, 0x00, 0x51, 0x92, 0x00, 0x00, 0xf3, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x41, 0xa2, 0x00, 0xf3, 0x20, 0x00, 0x41, 0xf3, 0x00, 0xf3, 0x41, 0x00, 0x41, 0xc3, 0x92, 0x82, 0x92, 0x51, 0x41, 0x51, 0x10, 0x10, 0x20, 0x00, 0x00, 0xf3, 0x82, 0xf3, 0x41, 0xc3, 0x20, 0x20, 0x20, 0xc3, 0xf3, 0xf3, 0xf3
		};

	// open file for output, gif image will be size w x h
	// return false on open file fails
	bool Start(const std::string& filename, int w, int h)
	{
		os.open(filename, std::ios::out | std::ios::binary);
		if (!os.is_open())
			return false;
		this->w = w;
		this->h = h;

		// Header Block
		Write("GIF89a");

		// Logical Screen Descriptor
		Write16(w); // canvas width
		Write16(h); // canvas height
		Write8(
			((useGlobalPalette?1:0) << 7) | // 1: has global color tbl 
			(((bitDepth-1)&7) << 4)       | // 3: color res this + 1 bits / channel
			(0 << 3)                      | // 1: palette not sorted
			((bitDepth-1)&7)                // 3: table size 2^(this+1)
		);
		// background color index, pixel aspect ratio not mentioned (assume 1.0)
		Write8({ 0,0 });  

		// Global Color Table
		if (useGlobalPalette) {
			os.write((const char*)palette.data(),palette.size());
		}

		// Comment block to tag this header
		std::string comment = "LomontGIF1.0";

		// GIF Extension code 0x21, Comment 0xFE, txt length
		Write8({ 0x21,0xFE,(int)(comment.size()) });
		Write(comment.c_str()); // comment text
		Write8(0);    // block terminator

		// Application Extension: animation header (todo - only if asked?)
		// GIF Extension code 0x21,  App specific 0xFF, length 0x0B
		Write8({0x21,0xFF,0x0B});
		Write("NETSCAPE2.0"); // legacy :)
		// 3 bytes data, must be 1, times to loop Lo/Hi, block terminator
		Write8({ 3,1,0,0,0 });
	}


	// delay in 100ths of sec
	// frame is taken so first 255 unique colors are palette, rest mapped to those
	void AddFrame(const uint8_t * rgbaData, uint16_t delayIn100thsOfSecond)
	{
		// todo - track alpha, local color table
		std::vector<uint8_t> pixels;
		ColorMapper(rgbaData, pixels);

		int pack =
			(0 << 5) | // 3: reserved
			(1 << 2) | // 3: disposal method : 0 = unspecified, 1=leave in place, 2=to background 
			(0 << 1) | // 1: no user input
			((hasTransparency?1:0) << 0);  // 1: transparency
		int delayLo = delayIn100thsOfSecond & 255;
		int delayHi = delayIn100thsOfSecond/256;
		// Extension 0x21, Graphic Control Extension 0xF9, byte size 4,
		// delay lo byte, delay high byte, transparent color index, block end
		Write8({ 0x21,0xF9,0x04, pack, delayLo, delayHi, transparentIndex, 0});

		// Image Descriptor 0x2C, left lo, left hi, top lo, top hi,
		// width low, width hi, height lo, height hi
		Write8({ 0x2C,0,0,0,0,w & 255,w / 256,h & 255,h / 256 });
		Write8(
			((useLocalPalettes ?1:0) << 7) | // 1: has local color table
			(0 << 6) |                       // 1: interlaced
			(0 << 5) |                       // 1: sorted palette
			(0 << 3) |                       // 2: reserved
			((bitDepth-1)&7)                 // 3: table size
		);
		if (useLocalPalettes)
			os.write((const char*)palette.data(), palette.size());

		// LZW table data
		LZW lzw(os,8, goodCompression);
		for (auto p : pixels)
		{
			lzw.AddPixelIndex(p);
		}
		lzw.End();

		Write8(0);   // block end

	}
	bool Write()
	{
		// trailer marks end of file
		Write8(0x3B);
		os.close();
		return true;
	}

private:

	void Write(const char* str)	{
		while (*str != 0)
			Write8(*str++);
	}
	void Write8(int v)	{
		os.put(v);
	}
	void Write8(std::initializer_list<int> lst)	{
		for (auto v : lst)
			os.put(v);
	}

	void Write16(int v)	{
		os.put(v & 255);
		os.put(v >> 8);
	}
	void Write(int val, int count) {
		for (int i = 0; i < count; ++i)
			Write8(val);
	}

	// can fake out table so it's not compressed,
	// https://github.com/Distrotech/libungif/blob/master/UNCOMPRESSED_GIF
	// but decoders still work
	// idea is to write each byte index as a 9 bit value, then every so often, emit clear code
	class LZW
	{
	private:
		std::ostream& os;
		int rootSize{ 8 };
		int compressionSize{ 9 };
		int clearCode{256}, endCode{257};
		bool goodCompression = true;

		// data here, each block at most 255 bytes in length
		std::array<uint8_t,255> dat{0};
		uint32_t bitPos = 0; // next open bit position (skip initial byte)

		void WriteBit(int val)
		{ // fill in bits low to high, flush, continue
			uint32_t shift = bitPos & 7;
			uint32_t bit = (val & 1) << shift; 
			uint32_t byteIndex = bitPos >> 3;
			dat.at(byteIndex) |= bit;
			bitPos++;
			if (bitPos == 8*255) 
				FlushBlock(); 
		}

		void WriteBits(int val) {
			for (int i = 0; i < compressionSize; ++i)
				WriteBit((val>>i) & 1);			
		}

		void FlushBlock() {
			const int byteCount = bitPos / 8;
			os.put(byteCount); // length
			os.write((const char*)dat.data(), byteCount); // block
			bitPos = 0; // reset
			std::memset(dat.data(), 0, dat.size());
		}


		void ClearCode()
		{
			WriteBits(clearCode);
			compressionSize = rootSize + 1;
			if (goodCompression)
				ClearDict();
		}

		int entries = 0; // tbl entries since last clear
		// add the next pixel index to the LZW using
		// the low memory, poor compression variant
		void AddPixelIndexBad(int pixelIndex) {
			WriteBits(pixelIndex);
			entries++;
			// todo - this too often, must deduce the rule?
			// 256 initial symbols 0-255, plus end,clear = 258
			// when hits 512, gets bit, so cannot hit that
			if (entries > 200) {
				entries = 0;
				ClearCode();
			}
		}

		std::unordered_map<std::string, int> dict;
		int dictSize = 0;
		void ClearDict()
		{
			dict.clear();
			dictSize = 1 << rootSize;
			for (int i = 0; i < dictSize; ++i)
			{
				std::string s(1, (char)i);
				dict[s] = i;
			}
			dictSize += 2; // add two special codes
		}

		std::string w = "";
		// add the next pixel index to the LZW using
		// the larger memory, good compression variant
		void AddPixelIndexGood(int pixelIndex) {
			// good explanation https://www.cs.cmu.edu/~guyb/realworld/lzexplained.html
			// Julia at Rosetta Code has nice structure https://rosettacode.org/wiki/LZW_compression#Julia
			// ClearDict();

			std::string cc(1, (char)pixelIndex);
			std::string wc = w + cc;
			if (dict.find(wc) != dict.end()) {
				w = wc;
			}
			else
			{
				WriteBits(dict[w]);
				dict[wc] = dictSize;
				dictSize++;
				if (dictSize-1  >= (1 << compressionSize))
				{
					compressionSize++;
				}
				if (dictSize >= 4095) // same as codesize == 13?
				{
					ClearCode();
				}
				w = cc;
			}
		}


	public:
		LZW(std::ostream& os, int codeSize, bool goodCompression)
		: os(os)
		, rootSize(codeSize)
		, compressionSize(codeSize+1)
		, clearCode(1 << codeSize)
		, endCode((1 << codeSize)+1)
		, goodCompression(goodCompression)
		{
			os.put(codeSize); // min code size
			ClearCode(); // // todo - is needed?
		}

		// add the next pixel index to the LZW
		void AddPixelIndex(int pixelIndex) {
			if (goodCompression)
				AddPixelIndexGood(pixelIndex);
			else
				AddPixelIndexBad(pixelIndex);
		}

		// end the LZW image
		void End() {
			ClearCode(); // // todo - is needed?
			WriteBits(endCode);

			// round up to pad byte, then flush
			bitPos = ((bitPos + 7) / 8) * 8;			
			FlushBlock();
		}		
	};



	// map data into pixel indices
	void ColorMapper(const uint8_t* rgbaData, std::vector<uint8_t>& pixels)	{
		pixels.clear();
		lruColors.clear();
		int index = 0;
		while (index < w * h * 4)
		{
			uint32_t r = rgbaData[index++];
			uint32_t g = rgbaData[index++];
			uint32_t b = rgbaData[index++];
			uint32_t a = rgbaData[index++];

			// closest color
			pixels.push_back(GetIndex(r, g, b, a));
		}
	}

	// todo - make all this better, fix LRU code
	std::vector<uint32_t> lruColors;
	// slow :)
	int GetIndex(int r, int g, int b, int a)
	{
		// todo - add alpha stuff
		uint32_t packed = (r << 24) | (g << 16) | (b << 8); // ignore alpha
		// check lru:
		for (int i = 0; i < lruColors.size(); ++i)
		for (uint32_t v : lruColors)
		{
			uint32_t c = v & 0xFFFFFF00U;
			if (c == packed)
			{
				// matches
				return v & 255; 
			}
		}

		// walk all
		int bestIndex = -1;
		int bestScore = 256 * 256 * 4; // way bigger
		for (int p = 0; p < 256; ++p)
		{
			auto dr = palette[p * 3] - r;
			auto dg = palette[p * 3 + 1] - g;
			auto db = palette[p * 3 + 2] - b;
			auto d = dr * dr + dg * dg + db * db;
			if (d < bestScore)
			{
				bestScore = d;
				bestIndex = p;
			}
		}
		if (lruColors.size() < 10) {
			lruColors.push_back(packed | bestIndex);			
		}
		return bestIndex;
	}

};
